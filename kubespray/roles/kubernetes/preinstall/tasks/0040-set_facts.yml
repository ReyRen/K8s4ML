---
# k8s-cluster 
- name: set architecture_groups
  set_fact:
    architecture_groups:
      x86_64: amd64
      aarch64: arm64
      armv7l: arm

- name: ansible_architecture_rename
  set_fact:
    host_architecture: >-
      {%- if ansible_architecture in architecture_groups -%}
      {{ architecture_groups[ansible_architecture] }}
      {%- else -%}
       {{ ansible_architecture }} # 内置变量
      {% endif %}

- name: check resolvconf
  shell: which resolvconf
  register: resolvconf
  failed_when: false
  changed_when: false
  check_mode: no

- name: set dns facts
  set_fact:
    resolvconf: >-
      {%- if resolvconf.rc == 0 -%}true{%- else -%}false{%- endif -%}

- name: check if kubelet is configured
  stat:
    path: "{{ kube_config_dir }}/kubelet.env"
  register: kubelet_configured
  changed_when: false

- name: check if early DNS configuration stage
  set_fact:
    dns_early: >-
      {%- if kubelet_configured.stat.exists -%}false{%- else -%}true{%- endif -%}

- name: target resolv.conf files
  set_fact:
    resolvconffile: /etc/resolv.conf
    base: >-
      {%- if resolvconf|bool -%}/etc/resolvconf/resolv.conf.d/base{%- endif -%}
    head: >-
      {%- if resolvconf|bool -%}/etc/resolvconf/resolv.conf.d/head{%- endif -%}
  when: not ansible_os_family in ["CoreOS", "Container Linux by CoreOS"]

- name: generate search domains to resolvconf
  set_fact:
    searchentries:
      search {{ ([ 'default.svc.' + dns_domain, 'svc.' + dns_domain ] + searchdomains|default([])) | join(' ') }}
    domainentry:
      domain {{ dns_domain }}
    supersede_search:
      supersede domain-search "{{ ([ 'default.svc.' + dns_domain, 'svc.' + dns_domain ] + searchdomains|default([])) | join('", "') }}";
    supersede_domain:
      supersede domain-name "{{ dns_domain }}";

- name: pick coredns cluster IP or default resolver
  set_fact:
    coredns_server: |-
      {%- if dns_mode == 'coredns' and not dns_early|bool -%}
        {{ [ skydns_server ] + upstream_dns_servers|default([]) }}
      {%- elif dns_mode == 'coredns_dual' and not dns_early|bool -%}
        {{ [ skydns_server ] + [ skydns_server_secondary ] + upstream_dns_servers|default([]) }}
      {%- elif dns_mode == 'manual' and not dns_early|bool -%}
        {{ ( manual_dns_server.split(',') | list) + upstream_dns_servers|default([]) }}
      {%- elif dns_early|bool -%}
        {{ upstream_dns_servers|default([]) }}
      {%- endif -%}

- name: generate nameservers to resolvconf
  set_fact:
    nameserverentries:
      nameserver {{ ( coredns_server + nameservers|d([]) + cloud_resolver|d([])) | unique | join(',nameserver ') }}
    supersede_nameserver:
      supersede domain-name-servers {{ ( coredns_server + nameservers|d([]) + cloud_resolver|d([])) | unique | join(', ') }};

- name: gather os specific variables
  include_vars: "{{ item }}"
  with_first_found:
    - files:
        - "{{ ansible_distribution|lower }}-{{ ansible_distribution_version|lower|replace('/', '_') }}.yml"
        - "{{ ansible_distribution|lower }}-{{ ansible_distribution_release }}.yml"
        - "{{ ansible_distribution|lower }}-{{ ansible_distribution_major_version|lower|replace('/', '_') }}.yml"
        - "{{ ansible_distribution|lower }}.yml"
        - "{{ ansible_os_family|lower }}.yml"
        - defaults.yml
      paths:
        - ../vars
      skip: true

- name: override kube_proxy_mode to ipvs if kube_proxy_remove is set, as ipvs won't require kube-proxy cleanup when kube-proxy daemonset gets deleted
  set_fact:
    kube_proxy_mode: 'ipvs'
  when:
    - kube_proxy_remove
  tags:
    - facts
    - kube-proxy

- name: set etcd vars if using kubeadm mode
  set_fact:
    etcd_cert_dir: "{{ kube_cert_dir }}"
    kube_etcd_cacert_file: "etcd/ca.crt"
    kube_etcd_cert_file: "apiserver-etcd-client.crt"
    kube_etcd_key_file: "apiserver-etcd-client.key"
    etcd_deployment_type: host
  when:
    - etcd_kubeadm_enabled
